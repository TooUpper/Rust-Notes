# 基本类型



Rust 数据类型可分为两类：**基本类型**和**复合类型**

基本类型为：

- 数值类型: 有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true`和`false`
- 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
- 单元类型: 即 `()` ，其唯一的值也是 `()`

## 类型推导与标注

Rust 编译器**在某些情况下可以根据变量的值和上下文环境中的使用方式来自动推导出变量的类型**，但有些时候他也无法推导出变量的类型这时候就需要**手动进行类型标注**。

```Rust
let guess = "42".parse().expect("Not a number!");
```

`cago run`运行

```Rust
$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^ consider giving `guess` a type
```

因此我们需要提供给编译器更多的信息，例如给 `guess` 变量一个**显式的类型标注**：`let guess: i32 = ...` 或者 `"42".parse::<i32>()`。

## 数值类型

### 整数类型

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | `i8`       | `u8`       |
| 16 位      | `i16`      | `u16`      |
| 32 位      | `i32`      | `u32`      |
| 64 位      | `i64`      | `u64`      |
| 128 位     | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |

`isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。

整数类型的默认值是`i32`

对于字面量为了方便阅读可以采用以下形式进行书写

| 数字字面量         | 示例          |
| ------------------ | ------------- |
| 十进制             | `98_222`      |
| 十六进制           | `0xff`        |
| 八进制             | `0o77`        |
| 二进制             | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'`        |

#### 溢出处理



使用`debug`模式编译时，Rust编译器会检查整形溢出，若存在则编译时panic。

可使用`--release`参数进行release构建，此时如果发生溢出，Rust编译器会使用补码的形式进行处理。例如在`u8`情况下：265 > 0, 268 > 1。

Rust 标准库也提供了一些显示处理的方式：

- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法使值达到最小值或最大值

```Rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```

### 浮点类型

| 长度  | 类型  |
| ----- | ----- |
| 32 位 | `f32` |
| 64 位 | `f64` |

`f32` 类型是单精度浮点型，`f64` 为双精度。默认浮点类型是`f64`。

#### 浮点数陷阱

1.**浮点数往往是你想要数字的近似表达**对于想要完全表达精准的数字，不要使用浮点类型，除非浮点数的精度为无限。

2.**浮点数在某些特性上是反直觉的**

浮点数并没有实现`std::cmp::Eq` 特征只实现了`std::cmp::PartialEq`特征，所以在进行结果比对时会出现与实际不相符甚至完全相反的情况。

**std::cmp::PartialEq**

- 定义了一个**偏序相等关系，即两个值可以比较相等，也可以比较不等**。
- 重载了`==`和`!=`运算符，用于比较相等性和不等性。

**std::cmp::Eq**

- 定义了一个**不可再分的相等关系，即两个值要么完全相等，要么完全不等**。
- 重载了`==`运算符，用于比较相等性。

所以 基于此的浮点类型在进行比较时可能会现与实际不相符甚至完全相反的情况。

例如：`a == b`为`true`，但`b == a`却可能为为`false`，这会导致混淆和意外的结果。

```Rust
// 例1
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3); 
 // 报错 panic 
 // 二进制无法准确表示十进制小数会在 N 位数后存在误差。
 // 导致了 0.1 + 0.2 并不严格等于 0.3。
}
```

那如果非要进行比较呢？可以考虑用这种方式 `(0.1_f64 + 0.2 - 0.3).abs() < 0.00001` ，具体小于多少，取决于你对精度的需求。

```Rust
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);

    println!("abc (f32)");
    println!("   0.1 + 0.2: {:x}", (abc.0 + abc.1).to_bits());
    println!("         0.3: {:x}", (abc.2).to_bits());
    println!();

    println!("xyz (f64)");
    println!("   0.1 + 0.2: {:x}", (xyz.0 + xyz.1).to_bits());
    println!("         0.3: {:x}", (xyz.2).to_bits());
    println!();

    assert!(abc.0 + abc.1 == abc.2);
    assert!(xyz.0 + xyz.1 == xyz.2);
}
```

`cargo run`运行

```Rust
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2',
➥ch2-add-floats.rs.rs:14:5
note: run with `RUST_BACKTRACE=1` environment variable to display
➥a backtrace
```

仔细看，对 `f32` 类型做加法时，`0.1 + 0.2` 的结果是 `3e99999a`，`0.3` 也是 `3e99999a`，因此 `f32` 下的 `0.1 + 0.2 == 0.3` 通过测试，但是到了 `f64` 类型时，结果就不一样了，因为 `f64` 精度高很多，因此在小数点非常后面发生了一点微小的变化，`0.1 + 0.2` 以 `4` 结尾，但是 `0.3` 以`3`结尾，这个细微区别导致 `f64` 下的测试失败了，并且抛出了异常。

#### NaN

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number)来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较。

### 运算符

| 运算符  | 说明                                                   |
| ------- | ------------------------------------------------------ |
| & 位与  | 相同位置均为1时则为1，否则为0                          |
| \| 位或 | 相同位置只要有1时则为1，否则为0                        |
| ^ 异或  | 相同位置不相同则为1，相同则为0                         |
| ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0                 |
| << 左移 | 所有位向左移动指定位数，右位补0                        |
| >> 右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

### 序列(Range)

Rust 提供了一个非常简洁的方式，用来生成连续的数值。

列如： `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5。

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

```Rust
for i in 1..=5 {
    println!("{}",i);
}
//	1
//	2
//	3
//	4
//	5
```



## 字符、布尔、单元类型

### 字符(char)

**Rust 中的 char 类型占 4 个字节**，是一个**标准的 `Unicode`标量值**。

### 布尔(bool)

**Rust 中的 bool 类型占 1 个字节**，值为 `true` 和 `false`

### 单元类型

单元类型就是`()`。

常见的`fn main()`方法返回的就是`()`，他并不是无返回，Rust 对于无返回的函数称为`发散函数(diverge function)`。

`()`作为值使用时，完全**不占**任何内存，可以当占位使用。

## 语句与表达式

Rust 的函数体是由一系列**语句**组成，最后由一个**表达式来**返回值。**表达式总要返回值**。

### 语句

**完成了一个具体的操作，但是并没有返回值**

`let`是语句，因此不能将`let`语句赋值给其他值。

### 表达式

表达式会进行求值，然后**返回一个值**。

**表达式可以成为语句的一部分**。

调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹最终返回一个值的语句块也是表达式，总之，能返回值，它就是表达式。

**表达式不包含分号**。

##  函数

在 Rust 中函数和变量名使用蛇形命名法，且每个函数参数都需要标注类型。

### 函数返回

Rust 中函数就是表达式，因此可以将函数体的最后一条表达式的直接返回给调用者，也可以使用`return`提前返回

 #### Rust 中的特殊返回类型

单元类型`()`,是一个零长度的元组。可以用来表达一个函数没有返回值：

- 函数没有返回值，那么返回一个 `()`
- 通过 `;` 结尾的表达式会返回一个 `()`

**永不返回的发散函数**

当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：

```rust
fn forever() -> ! {
  loop {
    //...
  };
}
```

